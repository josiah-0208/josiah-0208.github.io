---
layout: single
title: "Hoisting - JS엔진이 하는 일"
categories:
  - JavaScript

toc: true
toc_sticky: true
---



'Hoisting'의 개념
---


&nbsp; Hoist의 뜻은 들어(끌어)올리기이다.  
그렇다면 JS에서 Hoisting이란 무엇일까?  

<br/>
호이스팅(hoisting)이란,  
JS 인터프리터가  
**`'변수와 함수의 메모리 공간을 선언 전에 미리 할당하는 것'`**을 의미한다.  

<br/>
복잡한 표현으로는,

        "변수의 선언과 초기화를 분리한 후,  
        선언만 코드의 최상단으로 옮기는 것"  

이다.  

<br/>
쉽게 말해 선언을 최상위 순서로 끌어올리는 것이다.  
따라서, **변수를 정의하는 코드**보다 **사용하는 코드가 앞서 등장**할 수 있다.
다만 선언과 초기화를 함께 수행하는 경우,  
선언 코드까지 실행해야 변수가 초기화된 상태가 됨을 주의해야 한다.

<br/>
호이스팅의 존재로,  
우리가 알아야할 두 가지가 있다.  
* **var로 선언한 변수의 경우**, 호이스팅 시 undefined로 변수를 초기화한다.
* 반면, **let과 const로 선언한 변수의 경우**, 호이스팅 시 변수를 초기화하지 않는다.  

<br/>
또한, 이 호이스팅 규칙을 쉽게 3 가지로 정리하면
1. **`'선언된 함수'`**는 상단에서 참조, 호출이 가능하다.
2. **`'선언된 var'`** 는 상단에서 참조, 할당이 가능하다.
3. **`'선언된 let , const'`** 는 상단에서 참조, 할당이 불가능하다.  

<br/>
이 규칙들을 자세히 알아보자.


<br/>
함수 선언 전, 함수를 호출했을 때
---

&nbsp; 호이스팅을 설명할 수 있는 코드를 살펴보자.  

<br/>
함수 선언 전에, 함수를 호출한 경우의 예제이다.

```js
catName("나비"); // 선언 보다 앞선 호출

function catName(name) {
  console.log("제 고양이의 이름은 " + name + "입니다");
}

// 결과: "제 고양이의 이름은 나비입니다"

```  
<br/>
함수 호출이 함수 자체보다 앞에 있지만,  
그럼에도 불구하고 이 코드는 동작한다.  
이것이 JS에서 실행 컨텍스트가 동작하는 방식이다.  

<br/>
자바스크립트의 모든 자료형과 변수 선언에 호이스팅이 일어난다.  
그런데 `let`, `const`, `class`를 이용한 선언문은 호이스팅이 발생하지 않는 것처럼 동작한다.  
var 키워드로 선언된 변수와는 달리,  
`let`, `const`, `class` 키워드로 선언된 변수를 선언 이전에 참조하면, 참조 에러(ReferenceError)가 발생한다.  

<br/>
분명한건, 호이스팅은 모든 변수와 함수에서 필연적으로 일어나는 것인데,  
어떤 경우는 실행을 먼저 일으키는 행위를 할 때, 오류를 뱉는 것이다.  

<br/>
그 이유는 **'변수의 생성 과정'**을 통해 알 수 있다.


<br/>
변수 생성 과정과 'TDZ'
---

&nbsp; 변수는 프로그램 내에서 세 단계를 거친다.

* 1단계, 선언 : 변수를 실행 컨텍스트의 변수 객체에 등록한다.  
이 변수 객체는 스코프가 참조하는 대상이 된다.
* 2단계, 초기화 : 변수 객체에 등록된 변수를 위한 공간을 메모리에 확보한다.  
이 단계에서 변수는 undefined로 초기화 된다.
* 3단계, 할당 : undefined로 초기화된 변수에 실제 값을 할당한다.

이 세 단계를 토대로,  
**var과 let, const의 차이**를 알아보자. 

<br/>
`var`로 선언한 변수는 선언 단계와 초기화 단계가 한번에 이뤄진다.  
즉, 스코프에 변수를 등록(선언)하고, 메모리에 변수를 위한 공간을 확보한 후, **undefined로 초기화**한다.  
따라서, 변수 선언문 이전에 변수에 접근하여도 스코프에 변수가 존재하기 때문에 에러가 발생하지 않는다.  
**다만 undefined를 반환**한다.  
이후 변수 할당문에 도달하면 비로소 값이 할당된다.  

<br/>
`let`으로 선언된 변수는 선언 단계와 초기화 단계가 분리되어 진행된다.  
즉, 스코프에 변수를 등록(선언)하지만 **초기화 단계는 변수 선언문에 도달했을 때(코드 실행 후)** 이뤄진다.  
만약, 초기화 이전에 변수에 접근하려고 하면 참조 에러가 발생한다.  
이는 아직 변수가 초기화되지 않았기 때문이다.  
즉, 변수를 위한 메모리 공간이 아직 확보되지 않았기 때문이다.  
따라서 **스코프의 시작 지점부터 초기화 시작 지점까지는 변수를 참조할 수 없다.**  

<br/>
호이스팅은 선언만을 스코프 최상단으로 옮기므로,  
변수 스코프의 최상단부터 let과 const의 초기화 지점까지는 일시적 사각지대 (Temporal Dead Zone, TDZ)가 된다.  
일시적 사각지대 내부의 변수들은 아직 초기화가 진행되지 않은 상태,  
즉 메모리가 할당되지 않은 상태이므로 접근 시도시 ReferenceError를 발생시킨다.



생각정리
---

* 호이스팅은 에러 현상이 아니고,
* 호이스팅은 JS 모든 변수와 자료형에서 일어나는 것 
* 호이스팅은 물리적으로 최상단으로 올라가는 것이 아니라, 메모리에 먼저 선언되는 것  

<br/>
애초에 호이스팅이 일어나지 않도록 제어하자.  
다른 언어에서 당연한 것처럼 모든 선언은 코드 상단부에 적자.  

<br/>
var 대신에 es6에서 고안된 let과 const를 쓰자.  
eslint를 사용하는 것도 좋은 방법이 될 것 같다.

<br/>
호이스팅은 js를 더욱 유연하게 해주는 것일텐데, 이 유연함 때문에 알아야 할 것이 하나 더 생겼다.  
C로 개발을 접했어서 그런지 아직 이 유연함이 단점으로 다가온다.  

이 유연함이 나에게 강점이 되기를.


-----------------------------------


감사한 레퍼런스
- https://developer.mozilla.org/ko/docs/Glossary/Hoisting
- https://hanamon.kr/javascript-%ED%98%B8%EC%9D%B4%EC%8A%A4%ED%8C%85%EC%9D%B4%EB%9E%80-hoisting/
- https://gmlwjd9405.github.io/2019/04/22/javascript-hoisting.html
- https://tecoble.techcourse.co.kr/post/2021-04-25-hoisting/
- https://velog.io/@gml9812/%ED%98%B8%EC%9D%B4%EC%8A%A4%ED%8C%85%EC%9D%B4-%EB%AD%98%EA%B9%8C