---
layout: single
title: "Hoisting_JS엔진이 하는 일"

toc: true
toc_sticky: true
---

# 'Hoisting'


호이스팅(hoisting)이란,  
인터프리터가 **변수와 함수의 메모리 공간을 선언 전에 미리 할당하는 것**을 의미합니다.  
var로 선언한 변수의 경우 호이스팅 시 undefined로 변수를 초기화합니다. 반면 let과 const로 선언한 변수의 경우 호이스팅 시 변수를 초기화하지 않습니다.
호이스팅을 설명할 땐 주로 "변수의 선언과 초기화를 분리한 후, 선언만 코드의 최상단으로 옮기는" 것으로 말하곤 합니다.  따라서 변수를 정의하는 코드보다 사용하는 코드가 앞서 등장할 수 있습니다. 다만 선언과 초기화를 함께 수행하는 경우, 선언 코드까지 실행해야 변수가 초기화된 상태가 됨을 주의해야 한다.

이 호이스팅 규칙을 쉽게 3가지로 정리하면
1. 선언된 함수는 상단에서 참조, 호출이 가능하다.
2. 선언된 var 는 상단에서 참조, 할당이 가능하다.
3. 선언된 let , const 는 상단에서 참조, 할당이 불가능하다.

이다.

함수를 선언하기 전에 먼저 호출했을 때의 예제도 보겠습니다.
```js
catName("클로이");

function catName(name) {
  console.log("제 고양이의 이름은 " + name + "입니다");
}
/*
결과: "제 고양이의 이름은 클로이입니다"
*/
```
함수 호출이 함수 자체보다 앞서 존재하지만, 그럼에도 불구하고 이 코드 역시 동작합니다. 이것이 JavaScript에서 실행 맥락이 동작하는 방식입니다.

호이스팅은 다른 자료형과 변수에도 잘 작동합니다. 변수를 선언하기 전에 먼저 초기화하고 사용할 수 있는 것입니다.

자바스크립트의 모든 선언에는 호이스팅이 일어난다.
그런데 let, const, class를 이용한 선언문을 호이스팅이 발생하지 않는 것처럼 동작한다.
var 키워드로 선언된 변수와는 달리 let 키워드로 선언된 변수를 선언문 이전에 참조하면 참조 에러(ReferenceError)가 발생한다.
이는 let 키워드로 선언된 변수는 스코프의 시작에서 변수의 선언까지 *일시적 사각지대(Temporal Dead Zone; TDZ)에 빠지기 때문이다.

즉 모든 변수와 함수는 호이스팅이 필연적으로 일어난다.
근데 실행을 먼저 일으키는 행위를 할 때, 오류를 뱉는 것이다.

호이스팅은 실제로 코드들이 물리적으로 올라가는 것이 아니라

메모리에 먼저 선언된다는 것이다.

왜냐하면 정말 선언은 끌어올려진 것이 맞다. (표현하면 그렇고 정확히는 선언이 코드 실행 전에 메모리에 저장되었다는 의미이다.) 선언이 실행 순서가 빨라지는 느낌??
그런데 왜 오류가 나는가 하면 var 키워드는 선언과 함께 undefined로 초기화되어 메모리에 저장되는데 let과 const는 초기화되지 않은 상태로 선언만 메모리에 저장되기 때문이다.
초기화 되지 않으면 변수를 참조할 수 없다. 그래서 참조 에러를 일으키는 것이다.
let과 const에도 호이스팅이 일어나기 때문에 에러를 일으키는 것이다.

let과 const를 사용할 때 역시 호이스팅은 일어난다. 그러나 앞서 설명했듯, let과 const는 선언, 초기화, 할당이 각각 따로따로 일어난다.

변수는 프로그램 내에서 크게 세 가지 단계를 거친다.

선언 : 파싱 과정에서 변수 객체가 변수에 대한 식별자들을 수집한다.
초기화 : 식별자에 메모리를 할당하고 undefined 상태를 부여한다.
할당 : 변수 안에 직접 값을 넘겨 준다.


호이스팅은 선언만을 스코프 최상단으로 옮기므로, 변수 스코프의 최상단부터 let과 const가 위치한 지점까지는 일시적 사각지대 (Temporal Dead Zone, TDZ) 가 된다. 일시적 사각지대 내부의 변수들은 아직 초기화가 진행되지 않은 상태, 즉 메모리가 할당되지 않은 상태이므로 접근 시도시 ReferenceError를 발생시킨다.

let, const 가 동작하는 과정에서 스코프의 진입지점과 해당 식별자의 실질적 선언부 사이를 일시적 사각지대, TDZ(Temporal Dead Zone) 라고 한다. 여기서 변수는 존재하지만, 초기화가 되어있지 않다.

function do_something() {

------------------------------

모든 선언은 끌어올려진다.
하지만 let과 const는 초기화가 진행되지 않기 때문에
이게 보호가 된다.

var대신에 es6로 보완된 let과 const를 쓰고
변수와 함수의 선언을 코드 상단부에 미리 작성해서
애초에 호이스팅 현상이 일어나지 않도록 제어하는 것이 좋다
호이스팅은 js를 더욱 유연하게 만들어주는 것 같은데,
이 유연함을 피하는 것이 더 좋은 것 아닐까

eslint를 사용하는 것도 좋은 방법이 될 것 같다.


감사한 출처
- https://developer.mozilla.org/ko/docs/Glossary/Hoisting
- https://hanamon.kr/javascript-%ED%98%B8%EC%9D%B4%EC%8A%A4%ED%8C%85%EC%9D%B4%EB%9E%80-hoisting/
- https://gmlwjd9405.github.io/2019/04/22/javascript-hoisting.html
- https://tecoble.techcourse.co.kr/post/2021-04-25-hoisting/
- https://velog.io/@gml9812/%ED%98%B8%EC%9D%B4%EC%8A%A4%ED%8C%85%EC%9D%B4-%EB%AD%98%EA%B9%8C