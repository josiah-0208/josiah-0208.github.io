---
layout: single
title: "js에서의 스레드 / 작성 중"
categories:
    - JavaScript
tag: [스레드, Thread]

toc: true
toc_sticky: true
---

스레드를 알아 보기 전에 먼저 스레드 상위에 있는 프로세스를 알아야 한다. 

프로세스(process)란 단순히 실행 중인 프로그램(program)이라고 할 수 있다.  
즉, 사용자가 작성한 프로그램이 **운영체제에 의해 메모리 공간을 할당받아** CPU에서 실행 중인 것을 말합니다.
종종 '스케줄링의 대상이 되는 작업'이라는 용어와 거의 같이 쓰인다.

이러한 프로세스는 데이터(data) + 자원(memory) + ***스레드(Thread)**로 구성되어 있고,  
실제로 프로그램이 실행되기까지는 스레드가 데이터와 자원을 활용하여 작업을 수행한다.




바늘질할 때 쓰는 실을 뜻하는 스레드(Thread)는 프로그램의 실행 **단위**이다. 실행 단위 중에서도 프로세스보다 작은 실행 흐름 단위이다.
하나의 프로세스 내에서 여러 개의 실행 흐름(단일, 동시적, 병렬적)을 두어 작업을 효율적으로 처리하기 위한 모델이다.

어떤 프로세스든 하나 이상의 스레드가 수행된다.

두 개 이상의 스레드를 가지는 프로세스를 멀티스레드 프로세스라고 한다.

멀티스레드는 주어진 자원을 극한으로 사용하기 위한 모델이다.

프로세스 내에 스레드가 하나 있으면 single-theread multi-thread이다. 멀티스레드의 경우 동기화나 개발자가 직접 컨트롤해질 부분이 필요하다. 시간이 흐르며 손이 덜 가거나 그 간극이 굉장히 미세해지거나 할 수 있지만. 그래도 더 딮하게 개발할 것이라면 염두에 두는 것이 좋을 것 같다.
대신 자원에 대한 비용이 많이 들어가고, 동기화 

예를들어 포장 일을 하는데 일손이 부족하다고 치자. 그리고 선택지는 팔을 더 돋아나게 해서 일처리를 늘리는 방법과, 아예 분신술을 쓰는 방법 두 가지가 있다고 하자. 작업장의 크기가 한정되어 있다라고 가정하면 무엇이 더 효율적일까? 당연히 공간을 적게 먹는 노이토라가 노동생산성이 더 우수한 노동자임은 당연하다. 이렇게 멀티스레드와 멀티프로세스를 쉽게 비유할 수 있다. 하지만 따로 생각하고 따로 일하는 그림자분신과 달리 단순히 팔만 늘리고 뇌는 1개인 노이토라는 손이 꼬이거나 또는 어떤 손을 사용할까 하고 팔에 작업분배를 헷갈려서 문제가 생길 여지가 있다(병목현상, 데드락 등). 많아진 손을 적재적소에 놀지 않고 부지런히 일하려면 본인의 두뇌도 좋아야 한다라는 제반조건이 생긴다.

프로세스는 서로 완벽히 독립적인 공간을 가진다. 각자가 자기만의 스택과 데이터 영역을 가지고, 보호받는다. 프로세스는 시작할 때 운영체제에서 PCB[4]와 메모리 공간을 할당받고 초기화하는 과정이 필요하다. 다른 프로세스의 영역을 들여다볼 수 없기 때문에 프로세스끼리 통신하기 위해서 프로세스 간 통신[5]을 활용하거나 공유 메모리를 생성해 데이터를 주고 받는 등의 번거로운 과정을 거쳐야만 한다. 은행 지점을 하나 새로 세우려면 부동산을 계약하고 내부 인테리어 공사를 진행하며, 은행 지점끼리 연락하기 위해서는 사람이 직접 가거나 전화를 해야 하는 상황을 생각해보면 된다. 반면 한 프로세스가 비정상적으로 종료해도 다른 프로세스에는 영향이 거의 없다.[6] 은행 지점 하나가 화재 등으로 손상되어도 다른 지점에서 업무를 볼 수 있는 것과 비슷하다.

스레드는 스택은 따로따로이지만, 코드 영역과 데이터 영역은 하나를 공유한다. 데이터 영역에 속하는 변수[7]를 통해서 쉽고 빠르고 편하게 통신할 수 있다. 같은 은행 지점에서는 옆 창구에 말만 하면 바로 알아들을 수 있는 것과 비슷하다. 단, 스레드 하나가 잘못된 연산이나 버그 등으로 비정상 종료한다면 같은 프로세스에 소속된 다른 스레드들까지 모두 강제로 종료된다. 또한 스레드를 강제로 종료할경우 해당 스레드와 같은 자원을 공유하던 다른 스레드에 영향을 줄 가능성이 있기 때문에 스레드에 대해서 교육할때도 강제로 종료시키는것은 자제하라고 교육하는경우가 많고 프로그래밍 언어 설계적인 면에서도 임의대로 종료시키지 못하게 하는 방향으로 가고있다[8]

그럼 js는 싱글스레드인데, 어떻게 비동기 작업 병렬작업을 할 수 있을까?
미리 답을 말하자면 그 사이클이 매우 빠르게 일어나서 그렇게 보이는 것이다.

JS는 싱글 스레드 언어인데, 싱글 스레드의 특징은?

한 번에 하나의 일만 수행할 수 있는 것
문맥 교환(context switching)이 필요하지 않다.
프로그래밍 난이도가 쉽고 CPU 및 메모리를 적게 사용한다.
단순 CPU만을 사용하는 계산 작업은 오히려 멀티 스레드보다 더 효율적일 수 있다.
멀티 스레드는 번갈아가면서 작업을 수행해서 더 느릴 수도 있다.
연산량이 많은 작업을 할 경우 그 작업이 완료되어야 다른 작업을 할 수 있어서 멀티 스레드가 필요해진다.
에러 처리를 못 할 경우 멈춘다.

1. 자바스크립트는 왜 싱글 스레드를 선택했는가?
자바스크립트는 원래 웹페이지의 보조적인 기능을 수행하려고 만들어진 언어이다. 멀티 스레드인 자바는 다소 무겁고 어렵다는 인식도 있고 동시성 문제가 있다보니, 복잡한 시나리오를 신경쓸 필요 없는 싱글 스레드 형식이 채택되었다.

실제로 구글 Chrome 브라우저는 기존 웹 페이지에서 동시성 문제를 일으킬 수 있다는 이유로 단일 웹 사이트 페이지의 자바스크립트 코드가 동시에 실행되는 것을 허용하지 않는다.

3. 자바스크립트는 진짜 싱글 스레드인가?
자바스크립트의 메인 스레드인 이벤트 루프가 싱글 스레드이기 때문에 싱글 스레드라고 부른다. 하지만 이벤트 루프만 독립적으로 실행되지는 않고 웹 브라우저나 NodeJS같은 멀티 스레드 환경에서 실행된다. 즉, 자바스크립트 자체는 싱글스레드이지만 자바스크립트 런타임은 싱글 스레드가 아니다.

자바스크립트 런타임 자체에서 비동기 API를 지원하는가?
아니다. 정확히는 자바스크립트 엔진을 구동하는 런타임 환경에서 담당한다. 즉, 브라우저 혹은 Node.js가 담당한다.

런타임

프로그램이 실행되고 있을 때 존재하는 곳, 구동되는 환경
자바스크립트는 브라우저에서 작동하는 자바스크립트 측면도 있고 Node.js에서 구동되는 측면도 있다. 여기서 브라우저와 Node.js를 런타임이라고 한다.

그럼 어떻게 비동기 작업이 가능하지?
여기서 중요한 건 '자바스크립트' 이 자체로는 싱글 스레드가 맞다는 점입니다. 하지만 웹 개발을 하거나, 노드로 개발을 하는 과정에서 순수하게 자바스크립트만을 실행시키는 경우가 과연 많을까요? 특히 프론트엔드 입장이라면 자바스크립트 코드는 반드시 브라우저를 통해 실행되게 되어있습니다. 그리고 이 브라우저 때문에 싱글 스레드 언어인 자바스크립트가 우리 눈으로 보기엔 동시성을 갖는 작업을 해내는 것으로 보이게 됩니다.

이 포스팅이 이벤트 루프를 상세하게 설명하기 위한 포스팅은 아니기에, 엄청나게 상세한 디테일은 포함하지 않겠지만, 어쨌든 중요한 것은 자바스크립트의 코드는 이벤트 루프 기반으로 작동한다는 것입니다. 즉, 실행되는 함수를 싱글 스레드 형식으로 처리하는 메인 '콜 스택'이 있고, 이 콜 스택이 비었을 때마다 '콜백 큐'에서 대기 중인 함수를 콜 스택으로 불러와 실행시킵니다.


setTimeout이나 ajax 같은 비동기 함수가 호출되면, 해당 작업은 브라우저에 내장된 WebAPI에게 넘겨집니다. 그 안에서 타이머가 동작을 하거나 네트워크 통신을 진행하고, 코드가 실행될 준비가 되면 콜백 큐에 해당 작업을 넣어줍니다. 그래서 사실상 비동기 함수가 동기적인 함수들과 '동시'에 동작하는 것처럼 보이지만, 이는 아주 재빠르게 콜 스택에 넘어와 실행되었기 때문입니다. 즉, 모든 건 순차적으로 하나의 스레드(콜 스택) 안에서 돌아가고 우리는 그저 이 시간 차가 너무 작아서 동시에 돌아간다고 착각을 하는 것입니다.

http://www.tcpschool.com/java/java_thread_concept
gpt
나무위키
https://beststar-1.tistory.com/6
https://velog.io/@devmag/Javascript-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EB%8A%94-%EC%8B%B1%EA%B8%80-%EC%8A%A4%EB%A0%88%EB%93%9C%EC%9D%B8%EA%B0%80
https://stitchcoding.tistory.com/44
https://chanyeong.com/blog/post/44